<!DOCTYPE HTML>
<html>

<head>
</head>

<body bgColor="black">

	<!-- TODO: replace center with CSS -->
	<center><canvas id="myCanvas" width="800" height="600"></canvas></center>

	<script>
		// http://stackoverflow.com/a/7228322
		function random(min,max) {
			return Math.floor(Math.random()*(max-min+1)+min);
		}

		function maybe(chance) {
			chance = chance || 0.5;
			return Math.random() > 0.5;
		}

		// http://www.paulirish.com/2011/requestanimationframe-for-smart-animating/
		window.requestAnimFrame = (function() {
  			return  window.requestAnimationFrame       ||
          			window.webkitRequestAnimationFrame ||
          			window.mozRequestAnimationFrame    ||
          		function( callback ){
            		window.setTimeout(callback, 1000 / 60);
          		};
		})();

		function Sphere(i, minSize, maxSize,
			xRange, yRange, border, // inside screen
			influence, x, y) // TODO: outside player's influence
		{
			this.i = i;
			this.radius = random(minSize,maxSize);
			this.x = random(border+this.radius/2, xRange-border-this.radius/2);
			this.y = random(border+this.radius/2, yRange-border-this.radius/2);
			this.connected = true;
			//console.log("sphere #"+i+" at "+this.x+"x, "+this.y+"y");
		}
		Sphere.prototype.equals = function (other) {
			return other instanceof Sphere && other.i == this.i;
		}
        Sphere.prototype.renderSphere = function (context) {
        	if (this.connected) {
				context.save();

				// solid red circle
				context.beginPath();
				context.arc(this.x, this.y, this.radius, 0, 2 * Math.PI, false);
        		context.fillStyle = 'red';
				context.fill();

				context.globalCompositeOperation = 'screen';  // green + blue = cyan
				context.lineWidth = 2;
				var offset = Math.PI/4; // * myInfluence/maxInfluence

				// TODO: offset2 points the arc at the player's lights
				// ...which are outside the player, so this should work even
				// on the player itself

				// blue arc
				context.beginPath();
				context.arc(this.x, this.y,
						this.radius+3,
						offset,
						Math.PI/2+offset, false);
				context.strokeStyle = 'blue';
				context.stroke();

				// green arc
				context.beginPath();
				context.arc(this.x, this.y,
						this.radius+3,
						-offset,
						Math.PI/2-offset, false);
				context.strokeStyle = 'green';
				context.stroke();

				context.restore();
        	}
        	else
        	{
        		var offset = this.radius/3;  // TODO: myInfluence

				context.save();
				context.globalCompositeOperation = 'screen';  // green + blue = cyan

				// blue sphere
				context.beginPath();
				context.arc(this.x+offset, this.y, this.radius, 0, 2 * Math.PI, false);
        		context.fillStyle = 'blue';
				context.fill();

				// green sphere
				context.beginPath();
				context.arc(this.x-offset, this.y, this.radius, 0, 2 * Math.PI, false);
        		context.fillStyle = 'green';
				context.fill();

				context.restore();

        	}
        }

		function Player(x, y) {
			size = 25;
			this.sphere = (new Sphere(-1, size, size));
			this.sphere.connected = true;
			this.sphere.x = x;
			this.sphere.y = y;

			this.moveSpeed = 100;  // pixels per second
			this.turnSpeed = Math.PI/8  // radians per second
			this.facing = -Math.PI/2;  // up

			this.myInfluence = size+1;
			this.maxInfluence = size*4;
		}
		Player.prototype.caffeinate = function (dt) {
			var jitter = this.myInfluence / this.maxInfluence / 20 * dt;
        	this.sphere.x += (maybe()) ? jitter : -jitter;
        	this.sphere.y += (maybe()) ? jitter : -jitter;
        }
        Player.prototype.moveForward = function () {
        	var pps = this.moveSpeed * window.game.dt / 1000;  // speed in pixels per second
        	this.sphere.x += Math.cos(this.facing) * pps;
        	this.sphere.y += Math.sin(this.facing) * pps;
        	//console.log("moved sphere "+window.game.dt+" to "+this.sphere.x+","+this.sphere.y);
        }
        Player.prototype.turnLeft = function () {
			this.facing -= this.turnSpeed * window.game.dt;
			//console.log("facing "+this.facing);
        }
        Player.prototype.turnRight = function () {
			this.facing += this.turnSpeed * window.game.dt;
			//console.log("facing "+this.facing);
        }
		Player.prototype.renderPlayer = function (context) {
			this.sphere.renderSphere(context);  // red or bluegreen ball

			context.save();

			// cyan circle at influence range
			context.beginPath();
			context.arc(this.x, this.y, this.myInfluence, 0, 2 * Math.PI, false);
        	context.strokeStyle = 'cyan';
        	context.lineWidth = 2;
			context.stroke();

			context.restore();
		}

		function Game() {
			// canvas
			var canvas = document.getElementById('myCanvas');
			var context = canvas.getContext('2d');

			this.windowHeight = parseInt(document.getElementById("myCanvas").getAttribute("height"));
			this.windowWidth = parseInt(document.getElementById("myCanvas").getAttribute("width"));
			this.border = 10;

			// player
			this.player = new Player(this.windowWidth/2, this.windowHeight/2);

			// spheres
			this.spheres = [];
			this.numSpheres = 10;
			this.minSize = 3;
			this.maxSize = 15;
			var i;
			for (i=0; i<this.numSpheres; i++)
				this.spheres.push(new Sphere(i, this.minSize, this.maxSize,
						this.windowWidth, this.windowHeight, this.border,
						this.player.myInfluence, this.player.x, this.player.y));

			// start rendering
        	this.start = (new Date()).getTime();
			render(this, context, this.start);
		}

		render = function (game, context, last) {
			var now = (new Date()).getTime();
	        game.dt = now - last; // seconds since last frame
	        //console.log(now+" - "+last+" = "+dt);

			context.save();

			// background
			context.fillStyle = 'black';
			context.fillRect(0,0,game.windowWidth,game.windowHeight);

			// border
			context.strokeStyle = 'gray';
			context.lineWidth = 2;
			context.strokeRect(0,0,game.windowWidth,game.windowHeight);

			// logo
			context.font = '40pt "Zoetrope (BRK)"';
			context.fillStyle = 'red';
			context.fillText('Or Else They Will Disconnect You', 10, 50);

			// spheres
			for (i=0; i<game.numSpheres; i++)
				game.spheres[i].renderSphere(context);

			// player
			//game.player.caffeinate(game.dt);
			game.player.renderPlayer(context);

			context.restore();

			requestAnimFrame(function() { render(game, context, now); });
		}

		window.game = new Game();

		onKeyDown = function (event) {
    		switch (event.keyCode) {
        		case 37: // left arrow
        			this.game.player.turnLeft();
        			break;

        		case 39: // right arrow
        			this.game.player.turnRight();
        			break;

				case 32: // space bar
        		case 38: // up arrow
        		case 40: // down arrow
        			this.game.player.moveForward();
        			break;

        		default:
        			console.log("key: "+event.keyCode);
    		}
		}
		window.addEventListener('keydown', onKeyDown, false);
    </script>

</body>
</html>
