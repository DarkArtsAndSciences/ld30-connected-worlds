<!DOCTYPE HTML>
<html>

<head>
</head>

<body bgColor="black">

	<!-- TODO: replace center with CSS -->
	<center><canvas id="myCanvas" width="800" height="600"></canvas></center>

	<script>
		function maybe(chance) { return Math.random() < (chance || 0.5); }

		// http://stackoverflow.com/a/7228322
		function random(min,max) {
			return Math.floor(Math.random()*(max-min+1)+min);
		}

		// http://www.paulirish.com/2011/requestanimationframe-for-smart-animating/
		window.requestAnimFrame = (function() {
  			return  window.requestAnimationFrame       ||
          			window.webkitRequestAnimationFrame ||
          			window.mozRequestAnimationFrame    ||
          		function( callback ){
            		window.setTimeout(callback, 1000 / 60);
          		};
		})();

		// A Sphere represents a PC or NPC on screen.
		// A Sphere has a size and an x,y position on screen.
		// A Sphere can be connected (red) or disconnected (blue and green),
		// and its border shows the direction and intensity of (nearby?) lights.
		function Sphere(i, minSize, maxSize,
			xRange, yRange, border, // inside screen
			influence, x, y) // TODO: outside player's influence
		{
			this.i = i;  // not used?
			this.radius = random(minSize,maxSize);
			this.x = random(border+this.radius/2, xRange-border-this.radius/2);
			this.y = random(border+this.radius/2, yRange-border-this.radius/2);
			this.connected = true;
			//console.log("sphere #"+i+" at "+this.x+"x, "+this.y+"y");
		}
		Sphere.prototype.equals = function (other) {  // not used?
			return other instanceof Sphere && other.i == this.i;
		}
        Sphere.prototype.renderSphere = function (context) {
        	if (this.connected) {
				context.save();

				// solid red circle
				context.beginPath();
				context.arc(this.x, this.y, this.radius, 0, 2 * Math.PI, false);
        		context.fillStyle = 'red';
				context.fill();

				context.globalCompositeOperation = 'screen';  // green + blue = cyan
				context.lineWidth = 2;
				var offset = Math.PI/4; // * influence/maxInfluence

				// TODO: offset2 points the arc at the player's lights
				// ...which are outside the player, so this should work even
				// on the player itself

				// blue arc
				context.beginPath();
				context.arc(this.x, this.y,
						this.radius+3,
						offset,
						Math.PI/2+offset, false);
				context.strokeStyle = 'blue';
				context.stroke();

				// green arc
				context.beginPath();
				context.arc(this.x, this.y,
						this.radius+3,
						-offset,
						Math.PI/2-offset, false);
				context.strokeStyle = 'green';
				context.stroke();

				context.restore();
        	}
        	else
        	{
        		var offset = this.radius/3;  // TODO: influence at disconnection?

				context.save();
				context.globalCompositeOperation = 'screen';  // green + blue = cyan

				// blue sphere
				context.beginPath();
				context.arc(this.x+offset, this.y, this.radius, 0, 2 * Math.PI, false);
        		context.fillStyle = 'blue';
				context.fill();

				// green sphere
				context.beginPath();
				context.arc(this.x-offset, this.y, this.radius, 0, 2 * Math.PI, false);
        		context.fillStyle = 'green';
				context.fill();

				context.restore();
        	}
        }

		// A Player is a Sphere.
		// A Player turns left or right and moves forward.
		// A Player has influence, which disconnects nearby Spheres.
		// ...which increases the disconnector's influence.
		function Player(x, y, size) {
			this.sphere = (new Sphere(-1, size, size));
			this.sphere.connected = true;
			this.sphere.x = x;
			this.sphere.y = y;

			this.moveSpeed = 1;
			this.turnSpeed = 1;
			this.facing = -Math.PI/2;  // up

			this.movingForward = false;
			this.turningLeft = false;
			this.turningRight = false;
			this.caffeine = true;  // jitter

			this.influence = size;
			this.maxInfluence = size * 10;
		}

        Player.prototype.turnLeftOn = function () { this.turningLeft = true; }
        Player.prototype.turnLeftOff = function () { this.turningLeft = false; }
        Player.prototype.turnRightOn = function () { this.turningRight = true; }
        Player.prototype.turnRightOff = function () { this.turningRight = false; }
        Player.prototype.moveForwardOn = function () { this.movingForward = true; }
        Player.prototype.moveForwardOff = function () { this.movingForward = false; }

        Player.prototype.turnLeft = function (dt) { this.facing -= this.turnSpeed * dt; }
        Player.prototype.turnRight = function (dt) { this.facing += this.turnSpeed * dt; }

        Player.prototype.moveForward = function (dt) {
        	this.sphere.x += Math.cos(this.facing) * this.moveSpeed * dt;
        	this.sphere.y += Math.sin(this.facing) * this.moveSpeed * dt;
        }
		Player.prototype.caffeinate = function (dt) {
        	this.sphere.x += (maybe()) ? 0 : (maybe()) ? dt : -dt;
        	this.sphere.y += (maybe()) ? 0 : (maybe()) ? dt : -dt;
        }

        Player.prototype.move = function (dt) {
        	if (this.turningLeft && !this.turningRight) this.turnLeft(dt);
        	if (!this.turningLeft && this.turningRight) this.turnRight(dt);
        	dt *= this.influence/this.maxInfluence;
        	if (this.movingForward) this.moveForward(dt);
        	if (this.caffeine) this.caffeinate(dt/10);
        }

		Player.prototype.renderPlayer = function (context) {

			context.save();
        	context.lineWidth = 1;

			// cyan circle at influence range
			// TODO: should be two circles, one blue one green
			context.beginPath();
			context.arc(this.sphere.x - Math.sin(this.facing) * this.sphere.radius*0.25,
						this.sphere.y + Math.cos(this.facing) * this.sphere.radius*0.25,
						Math.max(1,this.influence), this.facing, this.facing + Math.PI, false);
        	context.strokeStyle = 'green';
			context.stroke();

			context.beginPath();
			context.arc(this.sphere.x + Math.sin(this.facing) * this.sphere.radius*0.25,
						this.sphere.y - Math.cos(this.facing) * this.sphere.radius*0.25,
						Math.max(1,this.influence), Math.PI+this.facing, 2 * Math.PI+this.facing, false);
        	context.strokeStyle = 'blue';
			context.stroke();

			// red or bluegreen ball
			this.sphere.renderSphere(context);

			// facing indicator
			context.beginPath();
			//context.moveTo(this.sphere.x, this.sphere.y);
        	context.moveTo(this.sphere.x + Math.cos(this.facing) * this.sphere.radius*0.9,
        				   this.sphere.y + Math.sin(this.facing) * this.sphere.radius*0.9);
        	context.lineTo(this.sphere.x + Math.cos(this.facing) * this.influence*1.1,
        				   this.sphere.y + Math.sin(this.facing) * this.influence*1.1);
        	context.strokeStyle = 'cyan';
        	context.stroke();

			context.restore();
		}

		function Game() {
			// audio
			this.disconnectSFX = new Audio('../assets/audio/disconnect.wav');
			this.reconnectSFX = new Audio('../assets/audio/reconnect.wav');
			this.healSFX = new Audio('../assets/audio/win.wav');

			// canvas
			var canvas = document.getElementById('myCanvas');
			var context = canvas.getContext('2d');

			this.height = parseInt(canvas.getAttribute("height"));
			this.width = parseInt(canvas.getAttribute("width"));
			this.border = 250;

			//this.range = 100;
			//this.scale = Math.min(this.range/this.height, this.range/this.width);
			//console.log(this.scale);

			this.level = 0;

			// player
			this.player = new Player(this.width/2, this.height/2, 10);

			// spheres
			this.numSpheres = 10;
			this.connected = 0;
			this.disconnected = 0;
			this.minSize = 1;
			this.maxSize = 11;

			this.spheres = [];
			for (var i=0; i<this.numSpheres; i++)
				this.spheres.push(new Sphere(i, this.minSize, this.maxSize,
						this.width, this.height, this.border,
						this.player.influence, this.player.x, this.player.y));

			// start rendering
        	this.start = (new Date()).getTime();
			render(this, context, this.start);
		}
		Game.prototype.next = function () {
			this.level++;
			console.log('level '+this.level);

			this.player.moveSpeed = 1 + this.level*0.1;
			this.player.turnSpeed = 0.001 * this.level;

			this.player.sphere.radius += this.level;
			this.player.influence = this.player.sphere.radius;
			this.player.maxInfluence = Math.max(1000/this.level, this.player.influence*2);
			console.log('size: '+this.player.sphere.radius
				+', influence: '+this.player.influence+'/'+this.player.maxInfluence);

			this.range = this.player.radius * 10 * this.level;  // not used?

			this.numSpheres = 2 + this.level*(this.level-1);
			this.minSize = 2 + this.level;
			this.maxSize = 20 + this.level*2;
			this.border = 100 - Math.min(99, this.level*this.level);

			this.spheres = [];  // recreate spheres
			this.connected = 0;
			this.disconnected = 0;
			for (var i=0; i<this.numSpheres; i++)
				this.spheres.push(new Sphere(i, this.minSize, this.maxSize,
						this.width, this.height, this.border,
						this.player.influence, this.player.x, this.player.y));
		}
		Game.prototype.lose = function () {
			this.level = -1;
			// play lose.wav
			// play ending cutscene, no interaction except restart at end
			console.log("you lose");
		}
		Game.prototype.win = function () {
			this.level = -2;
			// play win.wav
			// ending cutscene, then return to playground
			console.log("you win");
		}

		render = function (game, context, last) {
			var now = (new Date()).getTime();
	        var dt = now - last; // seconds since last frame
			context.save();

			// background
			context.fillStyle = 'black';
			context.fillRect(0,0,game.width,game.height);
			// TODO: starfield

	        // render game
	        if (game.level > 0) {
				// update game state
				var newInfluence = 0;
				var reconnected = 0;
				for (i=0; i<game.numSpheres; i++) {
					var sphere = game.spheres[i];
					var dx = sphere.x - game.player.sphere.x;
					var dy = sphere.y - game.player.sphere.y;
					var distance = Math.sqrt(dx*dx + dy*dy);
					var inRange = (distance < game.player.influence);

					if (sphere.connected && inRange) {
						sphere.connected = false;
						game.disconnected++;
						newInfluence += sphere.radius;

					} else if (!sphere.connected && !inRange) {
						// TODO: if enough time since disconnect timestamp
						if (maybe(1/100000 * dt))
						{
							sphere.connected = true;
							reconnected += sphere.radius;
						}
					}
				}
				var connected = 0;
				for (i=0; i<game.numSpheres; i++)
					if (game.spheres[i].connected)
						connected += 1;

				if (newInfluence > 0) {
					game.player.influence += newInfluence;
					console.log('Your influence increases to '+game.player.influence);

					game.disconnectSFX.play();

					// TODO: update lights
				}
				if (reconnected > 0) {
					console.log('Something is connecting your spheres! '+reconnected);

					game.player.influence -= reconnected/2;  // half what you lost
					console.log('Your influence decreases to '+game.player.influence);

					game.reconnectSFX.play();

					// TODO: update lights
				}

				// random healing
				// TODO: only while moving!
				if (game.disconnected && maybe(1/10000 * dt * connected/game.numSpheres))
				{
					game.player.influence -= game.disconnected;
					game.healSFX.play();
					// TODO: healLimit -= game.disconnected^2;
				}

				// check for level/game end conditions
				if (connected == 0)
					game.next();
				else if (game.player.influence > game.player.maxInfluence)
					game.lose();
				else if (game.player.influence <= 0)
					game.win();

				// react to input / move player
				else
					game.player.move(dt);

				// render spheres
				for (i=0; i<game.numSpheres; i++)
					game.spheres[i].renderSphere(context);

				// render player
				game.player.renderPlayer(context);

			// render other screens
			} else {

				// logo
				var offset = (now % (game.width/2 * 100))/100;
				context.save();
				context.globalCompositeOperation = 'screen';  // green + blue = cyan
				context.beginPath();
				context.arc(game.width/2+offset, game.height/3, 100, 0, 2 * Math.PI, false);
				context.fillStyle = 'blue';
				context.fill();
				context.beginPath();
				context.arc(game.width/2-offset, game.height/3, 100, 0, 2 * Math.PI, false);
				context.fillStyle = 'green';
				context.fill();
				context.restore();

				context.fillStyle = 'red';
				context.strokeStyle = 'black';
				context.lineWidth = 3;
				context.font = '36pt "Zoetrope (BRK)"';

				// title screen
				if (game.level == 0) {

					renderCenteredText(context, game.width/2, game.height/3-15,
							'Or Else They Will Disconnect You');
					renderCenteredText(context, game.width/2, game.height/3+45,
							'(2D Edition)');

					if (now % 800 < 600)
						renderCenteredText(context, game.width/2, game.height*3/4,
							'(press SPACE to play)');

				// lose
				} else if (game.level == -1) {

					renderCenteredText(context, game.width/2, game.height/4,
							'You split into two pieces,');
					renderCenteredText(context, game.width/2, game.height/2,
							'one green, one blue.');
					renderCenteredText(context, game.width/2, game.height*3/4,
							'Neither survives.');

				// win
				} else if (game.level == -2) {

					renderCenteredText(context, game.width/2, game.height/4,
							'You realize there is');
					renderCenteredText(context, game.width/2, game.height/2,
							'only one of you,');
					renderCenteredText(context, game.width/2, game.height*3/4,
							'and it has survived.');

				// error
				} else {
					console.log('something is wrong with level '+game.level);
				}
			}

			// border
			context.strokeStyle = 'gray';
			context.lineWidth = 2;
			context.strokeRect(0,0,game.width,game.height);

			context.restore();

			// and do it all again next frame
			requestAnimFrame(function() { render(game, context, now); });
		}

		function renderCenteredText(context, x, y, text) {
			x -= context.measureText(text).width/2;
			context.fillText(text, x, y);
			context.strokeText(text, x, y);
		}

		// create the game
		window.game = new Game();

		// keyboard controls:
		//   left/right arrow to turn,
		//   space or up/down arrow to move forward
		onKeyDown = function (event) {
    		switch (event.keyCode) {
        		case 37: // left arrow
        			this.game.player.turnLeftOn();
        			break;

        		case 39: // right arrow
        			this.game.player.turnRightOn();
        			break;

				case 32: // space bar
					if (this.game.level == 0) {
						this.game.next(); break;
					} else if (this.game.level < 0) {
						window.game = new Game(); break;
					}
        		//case 38: // up arrow
        		//case 40: // down arrow
        			this.game.player.moveForwardOn();
        			break;

        		//default:
        			//console.log("key down: "+event.keyCode);
    		}
		}
		window.addEventListener('keydown', onKeyDown, false);

		onKeyUp = function (event) {
    		switch (event.keyCode) {
        		case 37: // left arrow
        			this.game.player.turnLeftOff();
        			break;

        		case 39: // right arrow
        			this.game.player.turnRightOff();
        			break;

				case 32: // space bar
        		//case 38: // up arrow
        		//case 40: // down arrow
        			this.game.player.moveForwardOff();
        			break;

        		//default:
        			//console.log("key up: "+event.keyCode);
    		}
		}
		window.addEventListener('keyup', onKeyUp, false);
    </script>

</body>
</html>
