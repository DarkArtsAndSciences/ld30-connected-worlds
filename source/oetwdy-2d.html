<!DOCTYPE HTML>
<html>

<head>
</head>

<body bgColor="black">

	<!-- TODO: replace center with CSS -->
	<center><canvas id="myCanvas" width="800" height="600"></canvas></center>

	<script>
		function Game() {
			// setup audio
			this.disconnectSFX = new Audio('../assets/audio/disconnect.wav');
			this.reconnectSFX = new Audio('../assets/audio/reconnect.wav');
			this.healSFX = new Audio('../assets/audio/win.wav');

			// setup canvas
			var canvas = document.getElementById('myCanvas');
			this.height = parseInt(canvas.getAttribute("height"));
			this.width = parseInt(canvas.getAttribute("width"));

			// setup game
			this.level = 0;
			this.player = new Player();

			// start render loop
        	this.start = (new Date()).getTime();
			render(this, canvas.getContext('2d'), this.start);
		}
		Game.prototype.next = function () {
			// TODO: try NOT resetting vars and making new spheres, just reconnect the old, add a few (level number? ^2?) new ones, maybe a boss on %10 levels. Player speed is increasing too much. Maybe slowly reduce max influence, but cut current influence in half each level?

			// increment level number
			this.level++;
			console.log('level '+this.level);

			this.score = 0;  // number of spheres disconnected this level

			// increase move/turn speed
			//this.player.moveSpeed = 2 + this.level*0.25;
			//this.player.turnSpeed = 0.0025 * this.level;

			// increase player size
			//this.player.sphere.radius += this.level/10;
			//console.log('  player size: '+this.player.sphere.radius);

			// reset influence
			// TODO: influence should start at 0, make sure distance calcs include radius
			// (hit at circumference, not center point)
			this.player.influence = this.player.sphere.radius;
			//this.player.maxInfluence = Math.max(1000/this.level, this.player.influence*2);
			this.player.maxInfluence = this.player.influence*2;
			console.log('  influence: '+this.player.influence+'/'+this.player.maxInfluence);

			// increase sphere settings
			var numSpheres = 3 + this.level*(this.level-1);
			this.minSize = 1 + this.level;
			this.maxSize = 2 + this.level*this.level;
			console.log('  '+numSpheres+' spheres of size '+this.minSize+'-'+this.maxSize);

			this.border = Math.max(0, Math.floor(this.height/3) - this.level*this.level);
			console.log('  border: '+this.border);

			// recreate spheres
			if (this.spheres == undefined) {
				this.spheres = [];
				for (var i=0; i<numSpheres; i++) {
					var sphere = new Sphere();
					sphere.randomize(this.minSize, this.maxSize,
							this.width, this.height, this.border,
							this.player.influence, this.player.x, this.player.y);
					this.spheres.push(sphere);
				}
			} else {
				for (var i=0; i<this.spheres.length; i++) {
					this.spheres[i].connected = true;
					this.spheres[i].radius += 1;
				}
				var sphere = new Sphere();
				sphere.randomize(this.minSize, this.maxSize,
						this.width, this.height, this.border,
						this.player.influence, this.player.x, this.player.y);
				this.spheres.push(sphere);
			}

			this.connected = this.spheres.length;
			this.disconnected = 0;
		}

		// A Sphere represents a PC or NPC on screen.
		// A Sphere has a size and an x,y position on screen.
		// A Sphere can be connected (red) or disconnected (blue and green),
		// and its border shows the direction and intensity of (nearby?) lights.
		function Sphere() {
			this.radius = 1;
			this.connected = true;
		}
		Sphere.prototype.randomize = function (minSize, maxSize,
				xRange, yRange, border, // inside screen
				influence, x, y) { // TODO: outside player's influence
			this.radius = random(minSize,maxSize);
			this.x = random(border+this.radius/2, xRange-border-this.radius/2);
			this.y = random(border+this.radius/2, yRange-border-this.radius/2);
		}
		Sphere.prototype.center = function () {
			var canvas = document.getElementById('myCanvas');
			this.x = Math.floor(parseInt(canvas.getAttribute("width")) / 2);
			this.y = Math.floor(parseInt(canvas.getAttribute("height")) / 2);
		}

		// A Player is a Sphere.
		// A Player turns left or right and moves forward.
		// A Player has influence, which disconnects nearby Spheres.
		// ...which increases the disconnector's influence.
		function Player() {
			this.sphere = new Sphere();
			this.sphere.center();
			this.setSize(10);

			this.moveSpeed = 0.01;
			this.turnSpeed = 0.0025;
			this.facing = -Math.PI/2;  // up

			this.movingForward = true;
			this.turningLeft = false;
			this.turningRight = false;
		}
		Player.prototype.setSize = function (size) {
			this.sphere.radius = size;
			this.influence = size;
			this.maxInfluence = size * 10;
		}
		Player.prototype.influencePercent = function () {
			return this.influence/this.maxInfluence;
		}
		Player.prototype.excessInfluencePercent = function () {
			return Math.max(0.5, this.influence/this.maxInfluence)*2 - 1;
		}

        Player.prototype.turnLeftOn = function () { this.turningLeft = true; }
        Player.prototype.turnLeftOff = function () { this.turningLeft = false; }
        Player.prototype.turnRightOn = function () { this.turningRight = true; }
        Player.prototype.turnRightOff = function () { this.turningRight = false; }
        Player.prototype.moveForwardOn = function () { this.movingForward = true; }
        Player.prototype.moveForwardOff = function () { this.movingForward = false; }

        Player.prototype.turnLeft = function (dt) {
        	if (this.turningLeft && !this.turningRight)
        		this.facing -= this.turnSpeed * dt;
        }
        Player.prototype.turnRight = function (dt) {
        	if (!this.turningLeft && this.turningRight)
        		this.facing += this.turnSpeed * dt;
        }

        Player.prototype.moveForward = function (dt) {
        	// TODO: player controls acceleration, not velocity

        	var speed = this.sphere.radius * this.influence/this.maxInfluence * dt;
        	speed *= this.moveSpeed;
        	if (this.movingForward) {
        		this.sphere.x += Math.cos(this.facing) * speed;
        		this.sphere.y += Math.sin(this.facing) * speed;
        	}
        }
		Player.prototype.caffeinate = function (dt) {
			var speed = this.excessInfluencePercent() * dt / 10;
			// TODO: random angle and distance instead of x,y
        	this.sphere.x += (maybe()) ? 0 : (maybe()) ? speed : -speed;
        	this.sphere.y += (maybe()) ? 0 : (maybe()) ? speed : -speed;
        }

        Player.prototype.move = function (dt) {
        	// move player
        	this.turnLeft(dt);
        	this.turnRight(dt);
        	this.moveForward(dt);
        	this.caffeinate(dt);

			// move lights
			this.greenX = this.sphere.x - Math.sin(this.facing) * this.influence;
			this.greenY = this.sphere.y + Math.cos(this.facing) * this.influence;
			this.blueX  = this.sphere.x + Math.sin(this.facing) * this.influence;
			this.blueY  = this.sphere.y - Math.cos(this.facing) * this.influence;
        }

		render = function (game, context, last) {
			var now = (new Date()).getTime();
	        var dt = now - last; // seconds since last frame
			context.save();

			// background
			context.fillStyle = 'black';
			context.fillRect(0,0,game.width,game.height);
			// TODO: starfield

	        // render game
	        if (game.level > 0) {
				// update game state
				var newInfluence = 0;
				var reconnected = 0;
				for (i=0; i<game.spheres.length; i++) {
					var sphere = game.spheres[i];
					var dx = sphere.x - game.player.sphere.x;
					var dy = sphere.y - game.player.sphere.y;
					var distance = Math.sqrt(dx*dx + dy*dy);
					var inRange = (distance < game.player.influence);

					if (sphere.connected && inRange) {
						game.connected--;
						game.disconnected++;
						game.score++;
						sphere.connected = false;
						newInfluence += sphere.radius;

					} else if (!sphere.connected && !inRange) {
						// TODO: if enough time since disconnect timestamp
						if (maybe(1/100000 * dt))
						{
							game.connected++;
							game.disconnected--;
							sphere.connected = true;
							reconnected += sphere.radius;
						}
					}
				}

				if (newInfluence > 0) {
					game.player.influence += newInfluence;
					console.log('Your influence increases to '+game.player.influence+'/'+game.player.maxInfluence);

					game.disconnectSFX.play();
				}
				if (reconnected > 0) {
					console.log('Something is connecting your spheres! '+reconnected);

					game.player.influence -= reconnected/2;  // half what you lost
					console.log('Your influence decreases to '+game.player.influence+'/'+game.player.maxInfluence);

					game.reconnectSFX.play();
				}

				// random healing
				// only while moving
				// increases with disconnections since level start
				var healChance = 1/100000 * dt * game.score;
				if (game.player.movingForward && maybe(healChance)) {
					game.player.influence -= game.score;
					game.healSFX.play();

					console.log('Your influence decreases to '+Math.floor(game.player.influence)+'/'+game.player.maxInfluence);
				}

				// check for level/game end conditions
				if (game.connected == 0)
					game.next();
				else if (game.player.influence > game.player.maxInfluence)
					game.level = -1;
				else if (game.player.influence < 1)  // <= 0
					game.level = -2;

				// react to input / move player
				else
					game.player.move(dt);

				// render spheres
				for (i=0; i<game.spheres.length; i++)
					game.spheres[i].renderSphere(context, game.player);

				// render player
				game.player.renderPlayer(context);

				// render hud
				context.fillStyle = 'cyan';
				context.strokeStyle = 'black';
				context.lineWidth = 2;
				context.font = '24pt "Zoetrope (BRK)"';
				renderCenteredText(context, game.width/2, game.height-10, game.player.influence+'/'+game.player.maxInfluence);

			// render other screens
			} else {

				// logo
				var offset = (now % (game.width/2 * 100))/100;
				context.save();
				context.globalCompositeOperation = 'screen';  // green + blue = cyan
				context.beginPath();
				context.arc(game.width/2+offset, game.height/3, 100, 0, 2 * Math.PI, false);
				context.fillStyle = 'blue';
				context.fill();
				context.beginPath();
				context.arc(game.width/2-offset, game.height/3, 100, 0, 2 * Math.PI, false);
				context.fillStyle = 'green';
				context.fill();
				context.restore();

				context.fillStyle = 'red';
				context.strokeStyle = 'black';
				context.lineWidth = 3;
				context.font = '36pt "Zoetrope (BRK)"';

				// title screen
				if (game.level == 0) {

					renderCenteredText(context, game.width/2, game.height/3-15,
							'Or Else They Will Disconnect You');
					renderCenteredText(context, game.width/2, game.height/3+45,
							'(2D Edition)');

					if (now % 800 < 600)
						renderCenteredText(context, game.width/2, game.height*3/4,
							'(press SPACE to play)');

				// lose
				} else if (game.level == -1) {

					renderCenteredText(context, game.width/2, game.height/4,
							'You split into two pieces,');
					renderCenteredText(context, game.width/2, game.height/2,
							'one green, one blue.');
					renderCenteredText(context, game.width/2, game.height*3/4,
							'Neither survives.');

				// win
				} else if (game.level == -2) {

					renderCenteredText(context, game.width/2, game.height/4,
							'You realize there is');
					renderCenteredText(context, game.width/2, game.height/2,
							'only one of you,');
					renderCenteredText(context, game.width/2, game.height*3/4,
							'and it has survived.');

				// error
				} else {
					console.log('something is wrong with level '+game.level);
				}
			}

			// border
			context.strokeStyle = 'gray';
			context.lineWidth = 4;
			context.strokeRect(0,0,game.width,game.height);
			context.lineWidth = 1;
			context.strokeRect(game.border,game.border,
					game.width-game.border*2,game.height-game.border*2);

			context.restore();

			// and do it all again next frame
			requestAnimFrame(function() { render(game, context, now); });
		}

		// these arcs point at the player's lights
		// ...which are outside the player, so this should work even on the player itself
		Sphere.prototype.renderLighting = function (context, player) {
			context.save();
			context.globalCompositeOperation = 'screen';  // green + blue = cyan

			var minArc = Math.PI/8;
			var maxArc = Math.PI - minArc;
			var arcLength = minArc + maxArc * player.influence/player.maxInfluence;
			var arcWidth = 2;
			context.lineWidth = arcWidth;

			var blue = Math.atan2(  player.blueY - this.y,
									player.blueX - this.x);
			var green = Math.atan2(player.greenY - this.y,
								   player.greenX - this.x);

			// blue arc
			context.beginPath();
			context.arc(this.x, this.y, this.radius, blue-arcLength/2, arcLength/2+blue, false);
			context.strokeStyle = 'blue';
			context.stroke();

			// green arc
			context.beginPath();
			context.arc(this.x, this.y, this.radius, green-arcLength/2, arcLength/2+green, false);
			context.strokeStyle = 'green';
			context.stroke();

			context.restore();
		}
		Sphere.prototype.renderConnectedSphere = function (context) {
			// solid red circle
			context.beginPath();
			context.arc(this.x, this.y, Math.max(2,this.radius-3), 0, 2*Math.PI, false);
			context.fillStyle = 'red';
			context.fill();
		}
		Sphere.prototype.renderDisconnectedSphere = function (context) {
			context.save();
			context.globalCompositeOperation = 'screen';  // green + blue = cyan

			var offset = this.radius/3;  // TODO: influence at disconnection?

			// blue sphere
			context.beginPath();
			context.arc(this.x+offset, this.y, this.radius, 0, 2 * Math.PI, false);
			context.fillStyle = 'blue';
			context.fill();

			// green sphere
			context.beginPath();
			context.arc(this.x-offset, this.y, this.radius, 0, 2 * Math.PI, false);
			context.fillStyle = 'green';
			context.fill();

			context.restore();
		}
		Sphere.prototype.renderSphere = function (context, player) {
			if (this.connected) {
				this.renderConnectedSphere(context);
				this.renderLighting(context, player);
			} else {
				this.renderDisconnectedSphere(context);
			}
		}

		Player.prototype.renderPlayer = function (context) {
			//context.save();

			// red or bluegreen ball
			if (maybe(this.influence/this.maxInfluence))
				this.sphere.renderDisconnectedSphere(context);
			else
				this.sphere.renderConnectedSphere(context);
			this.sphere.renderLighting(context, this);

			// lights
			context.beginPath();
			context.arc(this.greenX, this.greenY, 2, this.facing, this.facing + Math.PI, false);
        	context.fillStyle = 'green';
			context.fill();

			context.beginPath();
			context.arc(this.blueX, this.blueY, 2, this.facing + Math.PI, this.facing + 2*Math.PI, false);
        	context.fillStyle = 'blue';
			context.fill();

			// facing indicator
			context.beginPath();
        	context.moveTo(this.sphere.x + Math.cos(this.facing) * this.sphere.radius*0.8,
        				   this.sphere.y + Math.sin(this.facing) * this.sphere.radius*0.8);
        	context.lineTo(this.sphere.x + Math.cos(this.facing) * this.influence,
        				   this.sphere.y + Math.sin(this.facing) * this.influence);
        	context.lineWidth = 1;
        	context.strokeStyle = 'cyan';
        	context.stroke();

			//context.restore();
		}

		function renderCenteredText(context, x, y, text) {
			x -= context.measureText(text).width/2;
			context.fillText(text, x, y);
			context.strokeText(text, x, y);
		}

		function maybe(chance) {
			if (chance == 0) return false;
			return Math.random() < (chance || 0.5);
		}

		// http://stackoverflow.com/a/7228322
		function random(min,max) {
			return Math.floor(Math.random()*(max-min+1)+min);
		}

		// http://www.paulirish.com/2011/requestanimationframe-for-smart-animating/
		window.requestAnimFrame = (function() {
  			return  window.requestAnimationFrame       ||
          			window.webkitRequestAnimationFrame ||
          			window.mozRequestAnimationFrame    ||
          		function( callback ){
            		window.setTimeout(callback, 1000 / 60);
          		};
		})();

		// create the game
		window.game = new Game();

		// keyboard controls:
		//   left/right arrow to turn,
		//   space or up/down arrow to move forward
		onKeyDown = function (event) {
    		switch (event.keyCode) {
        		case 37: // left arrow
        			this.game.player.turnLeftOn();
        			break;

        		case 39: // right arrow
        			this.game.player.turnRightOn();
        			break;

				case 32: // space bar
					if (this.game.level == 0) {
						this.game.next(); break;
					} else if (this.game.level < 0) {
						window.game = new Game(); break;
					}
        		//case 38: // up arrow
        		//case 40: // down arrow
        			this.game.player.moveForwardOff();
        			break;

        		//default:
        			//console.log("key down: "+event.keyCode);
    		}
		}
		window.addEventListener('keydown', onKeyDown, false);

		onKeyUp = function (event) {
    		switch (event.keyCode) {
        		case 37: // left arrow
        			this.game.player.turnLeftOff();
        			break;

        		case 39: // right arrow
        			this.game.player.turnRightOff();
        			break;

				case 32: // space bar
        		//case 38: // up arrow
        		//case 40: // down arrow
        			this.game.player.moveForwardOn();
        			break;

        		//default:
        			//console.log("key up: "+event.keyCode);
    		}
		}
		window.addEventListener('keyup', onKeyUp, false);
    </script>

</body>
</html>
